<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ian's Marine Weather Forecast</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
        }
        .container {
            max-width: 800px;
            margin: 2rem auto;
            min-height: 95vh;
            display: flex;
            flex-direction: column;
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            overflow: hidden;
            border: 1px solid #e5e7eb;
        }
        .tab-content {
            display: none;
            flex-grow: 1;
            padding: 1.5rem;
            overflow-y: auto;
        }
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        .tab-button {
            transition: all 0.3s ease;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab-button.active {
            border-color: #10b981;
            color: #10b981;
            font-weight: 600;
        }
        .message-box {
            padding: 1rem;
            border-radius: 0.75rem;
            font-weight: 500;
            text-align: center;
        }
        .message-box.info {
            background-color: #d1e5f8;
            color: #2c5282;
        }
        .message-box.success {
            background-color: #d4edda;
            color: #155724;
        }
        .message-box.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .message-box.warning {
            background-color: #fff3cd;
            color: #856404;
        }
        /* Custom scrollbar for a cleaner look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-500 to-cyan-500 p-4 min-h-screen flex items-center justify-center">

    <div class="container">
        <!-- Header -->
        <header class="p-6 bg-white border-b border-gray-200 text-center">
            <h1 class="text-3xl font-bold text-gray-800">âš“ Ian's Marine Weather Forecast</h1>
            <p class="text-lg text-gray-600">(Wanganella Banks)</p>
            <p id="user-id-display" class="mt-2 text-xs text-gray-400"></p>
        </header>

        <!-- Loading and Message Area -->
        <div id="status-message" class="p-4 hidden"></div>

        <!-- Start Date and Action Controls -->
        <div class="p-6 bg-white border-b border-gray-200">
            <div class="flex flex-col space-y-4">
                <div class="flex-1 w-full sm:w-auto">
                    <label for="start-date" class="block text-sm font-medium text-gray-700">Trip Start Date:</label>
                    <select id="start-date" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-emerald-500 focus:border-emerald-500 sm:text-sm rounded-md shadow-sm"></select>
                </div>
                <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                    <button id="run-analysis" class="w-full sm:w-auto px-6 py-3 bg-emerald-600 text-white rounded-lg shadow-md hover:bg-emerald-700 transition-colors duration-200 text-base font-semibold">Run Analysis</button>
                    <button id="clear-cache" class="w-full sm:w-auto px-6 py-3 bg-gray-200 text-gray-700 rounded-lg shadow-md hover:bg-gray-300 transition-colors duration-200 text-base font-semibold">Clear Data</button>
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <nav class="flex justify-around bg-gray-50 border-b border-gray-200 text-gray-500 font-medium">
            <button class="tab-button active flex-1 py-4 text-center" data-tab="dashboard">Dashboard</button>
            <button class="tab-button flex-1 py-4 text-center" data-tab="trip-analysis">Trip Analysis</button>
            <button class="tab-button flex-1 py-4 text-center" data-tab="fishing-forecast">Fishing Forecast</button>
        </nav>

        <!-- Main Content Area (Tab Content) -->
        <main class="flex-1 p-4 overflow-y-auto">

            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Current Waypoint Conditions</h2>
                <div id="dashboard-content" class="space-y-4">
                    <div class="message-box info">Please click "Run Analysis" to get the latest weather data.</div>
                </div>
            </div>

            <!-- Trip Analysis Tab -->
            <div id="trip-analysis" class="tab-content">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Fishing Trip Analysis</h2>
                <div id="trip-analysis-content" class="space-y-4">
                    <div class="message-box warning">Please run an analysis to see the report.</div>
                </div>
            </div>

            <!-- Fishing Forecast Tab -->
            <div id="fishing-forecast" class="tab-content">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Wanganella Bank Forecast</h2>
                <div id="fishing-forecast-content" class="space-y-4">
                    <div class="message-box warning">Please run an analysis to see the fishing forecast.</div>
                </div>
            </div>
        </main>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        setLogLevel('Debug');

        // Global variables for Firebase config and App ID
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- CONFIGURATION ---
        const CONFIG = {
          FORECAST_DAYS: 14,
          INTERVAL_HOURS: 3,
          VESSEL: {
            name: "M/V Distinction",
            cruising_speed_kts: 8
          },
          // Waypoints are now dynamic with a new Midpoint
          WAYPOINTS: [],
          ROUTE_SEGMENTS: [],
          TZ: "Pacific/Auckland",
          API_URLS: {
            marine: 'https://marine-api.open-meteo.com/v1/marine',
            weather: 'https://api.open-meteo.com/v1/forecast',
            currents: ''
          }
        };

        const SAFETY_THRESHOLDS = {
          DANGEROUS: { wind: 30, wave: 3.5 },
          MARGINAL: { wind: 20, wave: 2.5 },
          ACCEPTABLE: { wind: 15, wave: 1.5 }
        };

        // Static Waypoint Definitions
        const STATIC_WAYPOINTS = [
            { name: "Opua", lat: -35.3085, lon: 174.1218 },
            { name: "North_Cape", lat: -34.4167, lon: 173.0333 },
            { name: "Wanganella_Bank", lat: -32.55, lon: 167.31 },
        ];

        // --- DYNAMIC WAYPOINT AND ROUTE GENERATION ---
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distanceKm = R * c;
            return distanceKm * 0.539957; // Convert km to nautical miles (nm)
        }

        function generateTripWaypoints() {
            // Calculate midpoint coordinates for the outbound and return legs
            const opua = STATIC_WAYPOINTS[0];
            const northCape = STATIC_WAYPOINTS[1];
            const wanganellaBank = STATIC_WAYPOINTS[2];
            const midpoint1Lat = (opua.lat + northCape.lat) / 2;
            const midpoint1Lon = (opua.lon + northCape.lon) / 2;
            const midpoint2Lat = (northCape.lat + wanganellaBank.lat) / 2;
            const midpoint2Lon = (northCape.lon + wanganellaBank.lon) / 2;

            CONFIG.WAYPOINTS = [
                opua,
                { name: "Midpoint_1", lat: midpoint1Lat, lon: midpoint1Lon },
                northCape,
                { name: "Midpoint_2", lat: midpoint2Lat, lon: midpoint2Lon },
                wanganellaBank
            ];

            CONFIG.ROUTE_SEGMENTS = [
                { name: "Opua to Midpoint 1 (Outbound)", from: 0, to: 1, distance_nm: getDistance(CONFIG.WAYPOINTS[0].lat, CONFIG.WAYPOINTS[0].lon, CONFIG.WAYPOINTS[1].lat, CONFIG.WAYPOINTS[1].lon) },
                { name: "Midpoint 1 to North Cape (Outbound)", from: 1, to: 2, distance_nm: getDistance(CONFIG.WAYPOINTS[1].lat, CONFIG.WAYPOINTS[1].lon, CONFIG.WAYPOINTS[2].lat, CONFIG.WAYPOINTS[2].lon) },
                { name: "North Cape to Midpoint 2 (Outbound)", from: 2, to: 3, distance_nm: getDistance(CONFIG.WAYPOINTS[2].lat, CONFIG.WAYPOINTS[2].lon, CONFIG.WAYPOINTS[3].lat, CONFIG.WAYPOINTS[3].lon) },
                { name: "Midpoint 2 to Wanganella Bank (Outbound)", from: 3, to: 4, distance_nm: getDistance(CONFIG.WAYPOINTS[3].lat, CONFIG.WAYPOINTS[3].lon, CONFIG.WAYPOINTS[4].lat, CONFIG.WAYPOINTS[4].lon) },
                { name: "Fishing Day 1", from: 4, to: 4, distance_nm: 0 },
                { name: "Fishing Day 2", from: 4, to: 4, distance_nm: 0 },
                { name: "Fishing Day 3", from: 4, to: 4, distance_nm: 0 },
                { name: "Wanganella Bank to Midpoint 2 (Return)", from: 4, to: 3, distance_nm: getDistance(CONFIG.WAYPOINTS[4].lat, CONFIG.WAYPOINTS[4].lon, CONFIG.WAYPOINTS[3].lat, CONFIG.WAYPOINTS[3].lon) },
                { name: "Midpoint 2 to North Cape (Return)", from: 3, to: 2, distance_nm: getDistance(CONFIG.WAYPOINTS[3].lat, CONFIG.WAYPOINTS[3].lon, CONFIG.WAYPOINTS[2].lat, CONFIG.WAYPOINTS[2].lon) },
                { name: "North Cape to Midpoint 1 (Return)", from: 2, to: 1, distance_nm: getDistance(CONFIG.WAYPOINTS[2].lat, CONFIG.WAYPOINTS[2].lon, CONFIG.WAYPOINTS[1].lat, CONFIG.WAYPOINTS[1].lon) },
                { name: "Midpoint 1 to Opua (Return)", from: 1, to: 0, distance_nm: getDistance(CONFIG.WAYPOINTS[1].lat, CONFIG.WAYPOINTS[1].lon, CONFIG.WAYPOINTS[0].lat, CONFIG.WAYPOINTS[0].lon) },
            ];
        }

        // ===== APP STATE AND CORE LOGIC =====
        const state = {
            db: null,
            auth: null,
            userId: null,
            isAuthReady: false,
            startDateOffset: 0,
            allWeatherData: {},
            tripAnalysis: null,
        };

        const elements = {
            statusMessage: document.getElementById('status-message'),
            startDateSelect: document.getElementById('start-date'),
            runAnalysisBtn: document.getElementById('run-analysis'),
            clearCacheBtn: document.getElementById('clear-cache'),
            userIdDisplay: document.getElementById('user-id-display'),
            tabButtons: document.querySelectorAll('.tab-button'),
            tabContents: document.querySelectorAll('.tab-content'),
            dashboardContent: document.getElementById('dashboard-content'),
            tripAnalysisContent: document.getElementById('trip-analysis-content'),
            fishingForecastContent: document.getElementById('fishing-forecast-content'),
        };

        function showMessage(message, type = 'info') {
            console.log(`STATUS: ${message}`);
            const el = elements.statusMessage;
            el.innerHTML = `<div class="message-box ${type}">${message}</div>`;
            el.classList.remove('hidden');
        }

        function hideMessage() {
            elements.statusMessage.classList.add('hidden');
        }

        // --- Firebase Functions ---
        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                state.db = getFirestore(app);
                state.auth = getAuth(app);

                onAuthStateChanged(state.auth, async (user) => {
                    console.log("Auth state changed. User:", user ? user.uid : "anonymous");
                    state.isAuthReady = true;

                    if (user) {
                        state.userId = user.uid;
                        elements.userIdDisplay.textContent = `User ID: ${state.userId}`;
                        await loadSettings();
                    } else {
                        state.userId = crypto.randomUUID();
                        elements.userIdDisplay.textContent = `Signed in anonymously.`;
                    }

                    renderUI();
                });

                if (initialAuthToken) {
                    await signInWithCustomToken(state.auth, initialAuthToken);
                } else {
                    await signInAnonymously(state.auth);
                }

                console.log("Firebase initialization initiated.");
            } catch (error) {
                console.error("Firebase initialization error:", error);
                showMessage("Failed to initialize Firebase. Please try again later.", 'error');
            }
        }

        async function saveSettings() {
            if (!state.isAuthReady || !state.userId || !state.auth.currentUser) {
                console.error("Auth not ready or user not signed in. Cannot save settings.");
                return;
            }
            try {
                const settingsDocRef = doc(state.db, `artifacts/${appId}/users/${state.userId}/app_settings/main`);
                await setDoc(settingsDocRef, {
                    startDateOffset: state.startDateOffset
                });
                console.log("Settings saved to Firestore.");
            } catch (error) {
                console.error("Failed to save settings:", error);
            }
        }

        async function loadSettings() {
            if (!state.isAuthReady || !state.userId) {
                console.error("Auth not ready. Cannot load settings.");
                return;
            }
            try {
                console.log("Attempting to load settings for userId:", state.userId);
                const settingsDocRef = doc(state.db, `artifacts/${appId}/users/${state.userId}/app_settings/main`);
                const docSnap = await getDoc(settingsDocRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    state.startDateOffset = data.startDateOffset || 0;
                    elements.startDateSelect.value = state.startDateOffset;
                    console.log("Settings loaded from Firestore:", data);
                } else {
                    console.log("No settings found in Firestore. Using default values.");
                }
            } catch (error) {
                console.error("Failed to load settings:", error);
            }
        }

        // --- API Data and Logic from Script ---
        function getConditionsDescription(wind, wave) {
            if (wind === null || wave === null) return "Data Unavailable";
            if (wind > 30 || wave > 3.5) return "Dangerous";
            if (wind > 20 || wave > 2.5) return "Rough";
            if (wind > 15 || wave > 1.5) return "Moderate";
            if (wind > 10 || wave > 1.0) return "Slight";
            return "Calm";
        }

        function formatDate(timestamp) {
            return new Date(timestamp).toLocaleDateString("en-NZ", { timeZone: CONFIG.TZ });
        }

        function formatTime(timestamp) {
            const options = {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: CONFIG.TZ
            };
            return new Date(timestamp).toLocaleString("en-NZ", options);
        }

        async function fetchWithRetry(url) {
            let attempts = 0;
            const maxAttempts = 3;
            const initialDelay = 1000;

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}: ${response.statusText}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Attempt ${attempts + 1} failed for ${url}:`, error);
                    attempts++;
                    if (attempts < maxAttempts) {
                        const delay = initialDelay * Math.pow(2, attempts - 1);
                        console.log(`Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw new Error(`Failed to fetch data after ${maxAttempts} attempts: ${error.message}`);
                    }
                }
            }
        }

        async function fetchWaypointData(waypoint) {
            console.log(`Fetching data for waypoint: ${waypoint.name}`);
            const marineUrl = `${CONFIG.API_URLS.marine}?latitude=${waypoint.lat}&longitude=${waypoint.lon}&hourly=wave_height&forecast_days=${CONFIG.FORECAST_DAYS}&timezone=${CONFIG.TZ}`;
            const weatherUrl = `${CONFIG.API_URLS.weather}?latitude=${waypoint.lat}&longitude=${waypoint.lon}&hourly=wind_speed_10m&forecast_days=${CONFIG.FORECAST_DAYS}&timezone=${CONFIG.TZ}&wind_speed_unit=kn`;

            let marineData, weatherData;

            try {
                marineData = await fetchWithRetry(marineUrl);
            } catch(e) {
                console.error(`Marine API failed for ${waypoint.name}: ${e.message}`);
            }

            try {
                weatherData = await fetchWithRetry(weatherUrl);
            } catch(e) {
                console.error(`Weather API failed for ${waypoint.name}: ${e.message}`);
            }

            if (!weatherData && !marineData) {
                throw new Error("Both primary APIs failed to provide necessary data.");
            }

            const combined = [];
            const weatherTimes = weatherData?.hourly?.time || [];
            const marineTimes = marineData?.hourly?.time || [];
            const allTimes = Array.from(new Set([...weatherTimes, ...marineTimes])).sort();

            for (const time of allTimes) {
                const weatherIndex = weatherTimes.indexOf(time);
                const marineIndex = marineTimes.indexOf(time);

                let wind = (weatherIndex !== -1) ? weatherData.hourly.wind_speed_10m[weatherIndex] : null;
                let wave = (marineIndex !== -1) ? marineData.hourly.wave_height[marineIndex] : null;

                if (wind === null && wave === null) {
                    continue;
                }

                combined.push({
                    time: new Date(time).getTime(),
                    wind: wind,
                    wave: wave,
                    currents: 'N/A' // No currents API for now
                });
            }

            if (combined.length === 0) {
                throw new Error("No valid data points could be generated.");
            }

            console.log(`Successfully fetched ${combined.length} data points for ${waypoint.name}`);
            return combined;
        }

        async function fetchAllWaypointWeather() {
            const results = {};
            const waypointPromises = CONFIG.WAYPOINTS.map(waypoint => {
                return fetchWaypointData(waypoint)
                    .then(data => {
                        results[waypoint.name] = data;
                    })
                    .catch(e => {
                        console.error(`Failed to fetch ${waypoint.name}: ${e.message}`);
                        results[waypoint.name] = null; // Store null to indicate failure
                    });
            });

            await Promise.all(waypointPromises);
            return results;
        }

        function analyzeSegment(segment, weatherData, startIndex) {
            const fromWp = CONFIG.WAYPOINTS[segment.from];
            const toWp = CONFIG.WAYPOINTS[segment.to];

            let wpData = weatherData[fromWp.name];
            if (segment.distance_nm === 0) {
                wpData = weatherData[toWp.name];
            }

            const baseAnalysis = {
                name: segment.name,
                from: fromWp.name.replace(/_/g, ' '),
                to: toWp.name.replace(/_/g, ' '),
                duration: segment.distance_nm === 0 ? 24 : Math.round(segment.distance_nm / CONFIG.VESSEL.cruising_speed_kts),
                startTime: "N/A",
                maxWind: null,
                maxWave: null,
                safety: "UNKNOWN",
                conditions: "No data"
            };

            if (!wpData || wpData.length === 0) {
                console.warn(`No weather data available for segment: ${segment.name}`);
                return baseAnalysis;
            }

            let analysisHours = segment.distance_nm === 0 ? 24 : Math.ceil(segment.distance_nm / CONFIG.VESSEL.cruising_speed_kts);
            let dataPoints = Math.ceil(analysisHours / CONFIG.INTERVAL_HOURS);
            let maxWind = -Infinity;
            let maxWave = -Infinity;
            let hasWind = false;
            let hasWave = false;

            if (startIndex < wpData.length) {
                baseAnalysis.startTime = formatTime(wpData[startIndex].time);
                const endIndex = Math.min(startIndex + dataPoints, wpData.length);
                for (let i = startIndex; i < endIndex; i++) {
                    if (wpData[i]) {
                        if (wpData[i].wind !== null) {
                            maxWind = Math.max(maxWind, wpData[i].wind);
                            hasWind = true;
                        }
                        if (wpData[i].wave !== null) {
                            maxWave = Math.max(maxWave, wpData[i].wave);
                            hasWave = true;
                        }
                    }
                }
            } else {
                console.warn(`Start index ${startIndex} is out of bounds for waypoint data. Skipping analysis for segment: ${segment.name}`);
                return baseAnalysis;
            }

            // Set max values to null if no data was found
            if (!hasWind) maxWind = null;
            if (!hasWave) maxWave = null;

            let safety = "SAFE";
            let conditions = "Good";

            if (maxWind === null || maxWave === null) {
                safety = "UNKNOWN";
                conditions = "Data Unavailable";
            } else if (maxWind > SAFETY_THRESHOLDS.DANGEROUS.wind || maxWave > SAFETY_THRESHOLDS.DANGEROUS.wave) {
                safety = "DANGEROUS";
                conditions = `Dangerous: ${maxWind.toFixed(0)}kt, ${maxWave.toFixed(1)}m`;
            } else if (maxWind > SAFETY_THRESHOLDS.MARGINAL.wind || maxWave > SAFETY_THRESHOLDS.MARGINAL.wave) {
                safety = "MARGINAL";
                conditions = `Rough: ${maxWind.toFixed(0)}kt, ${maxWave.toFixed(1)}m`;
            } else if (maxWind > SAFETY_THRESHOLDS.ACCEPTABLE.wind || maxWave > SAFETY_THRESHOLDS.ACCEPTABLE.wave) {
                safety = "ACCEPTABLE";
                conditions = `Moderate: ${maxWind.toFixed(0)}kt, ${maxWave.toFixed(1)}m`;
            } else {
                conditions = `Good: ${maxWind.toFixed(0)}kt, ${maxWave.toFixed(1)}m`;
            }

            return {
                ...baseAnalysis,
                maxWind: hasWind ? maxWind.toFixed(1) : 'N/A',
                maxWave: hasWave ? maxWave.toFixed(1) : 'N/A',
                safety: safety,
                conditions: conditions
            };
        }

        function analyzeTrip(weatherData, startDayOffset = 0) {
            console.log(`Starting trip analysis for day offset: ${startDayOffset}`);
            const analysis = {
                segments: [],
                totalHours: 0,
                status: "ANALYZING",
                warnings: [],
                recommendation: "Calculating...",
                startDay: startDayOffset + 1
            };

            const startHourIndex = startDayOffset * (24 / CONFIG.INTERVAL_HOURS);
            let currentHourIndex = startHourIndex;
            let dangerousCount = 0;
            let marginalCount = 0;

            CONFIG.ROUTE_SEGMENTS.forEach(segment => {
                const segmentAnalysis = analyzeSegment(segment, weatherData, currentHourIndex);
                analysis.segments.push(segmentAnalysis);
                analysis.totalHours += segmentAnalysis.duration;

                if (segmentAnalysis.safety === "DANGEROUS") {
                    dangerousCount++;
                    analysis.warnings.push(`DANGEROUS: ${segment.name}`);
                } else if (segmentAnalysis.safety === "MARGINAL") {
                    marginalCount++;
                }

                currentHourIndex += Math.ceil(segmentAnalysis.duration / CONFIG.INTERVAL_HOURS);
            });

            if (dangerousCount > 0) {
                analysis.status = "DANGEROUS CONDITIONS";
                analysis.recommendation = "ðŸ”´ DO NOT PROCEED - Dangerous conditions expected";
            } else if (marginalCount > 2) {
                analysis.status = "MULTIPLE MARGINAL CONDITIONS";
                analysis.recommendation = "ðŸŸ¡ PROCEED WITH EXTREME CAUTION";
            } else if (marginalCount > 0) {
                analysis.status = "SOME MARGINAL CONDITIONS";
                analysis.recommendation = "ðŸŸ¡ PROCEED WITH CAUTION";
            } else {
                analysis.status = "FAVORABLE CONDITIONS";
                analysis.recommendation = "ðŸŸ¢ GOOD TO GO - Favorable conditions";
            }

            console.log("Trip analysis complete.");
            return analysis;
        }

        // --- UI Rendering Functions ---
        function renderUI() {
            elements.startDateSelect.innerHTML = '';
            const today = new Date();
            for (let i = 0; i < 9; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() + i);
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Day ${i + 1} (${formatDate(date.getTime())})`;
                elements.startDateSelect.appendChild(option);
            }
            elements.startDateSelect.value = state.startDateOffset;

            renderDashboard();
            renderTripAnalysis();
            renderFishingForecast();
        }

        function getDailySummary(waypointData) {
            const dailySummaries = {};
            if (!waypointData || waypointData.length === 0) return dailySummaries;

            waypointData.forEach(point => {
                const date = formatDate(point.time);
                if (!dailySummaries[date]) {
                    dailySummaries[date] = {
                        date: date,
                        minWind: Infinity,
                        maxWind: -Infinity,
                        minWave: Infinity,
                        maxWave: -Infinity,
                        hasWind: false,
                        hasWave: false
                    };
                }
                if (point.wind !== null) {
                    dailySummaries[date].minWind = Math.min(dailySummaries[date].minWind, point.wind);
                    dailySummaries[date].maxWind = Math.max(dailySummaries[date].maxWind, point.wind);
                    dailySummaries[date].hasWind = true;
                }
                if (point.wave !== null) {
                    dailySummaries[date].minWave = Math.min(dailySummaries[date].minWave, point.wave);
                    dailySummaries[date].maxWave = Math.max(dailySummaries[date].maxWave, point.wave);
                    dailySummaries[date].hasWave = true;
                }
            });
            return Object.values(dailySummaries);
        }

        function renderDashboard() {
            const contentDiv = elements.dashboardContent;
            contentDiv.innerHTML = '';
            const data = state.allWeatherData;

            if (Object.keys(data).length === 0) {
                contentDiv.innerHTML = '<div class="message-box info">Please click "Run Analysis" to get the latest weather data.</div>';
                return;
            }

            let htmlContent = '';
            let failedWaypoints = [];

            CONFIG.WAYPOINTS.forEach(waypoint => {
                const wpData = data[waypoint.name];
                if (!wpData) {
                    failedWaypoints.push(waypoint.name);
                    return;
                }

                const dailySummary = getDailySummary(wpData);
                let waypointHtml = `<h3 class="text-xl font-bold mb-2 mt-4 text-center sm:text-left">${waypoint.name.replace(/_/g, ' ')}</h3>`;
                waypointHtml += `<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">`;

                dailySummary.forEach(day => {
                    const conditions = getConditionsDescription(day.maxWind, day.maxWave);
                    let bgColor = '';
                    switch(conditions) {
                        case 'Calm':
                        case 'Slight':
                            bgColor = 'bg-emerald-100';
                            break;
                        case 'Moderate':
                            bgColor = 'bg-yellow-100';
                            break;
                        case 'Rough':
                            bgColor = 'bg-orange-100';
                            break;
                        case 'Dangerous':
                            bgColor = 'bg-red-100';
                            break;
                        default:
                            bgColor = 'bg-gray-100';
                    }
                    const cardHtml = `
                        <div class="${bgColor} border border-gray-200 rounded-xl p-4 shadow-sm transition-transform transform hover:scale-105">
                            <p class="font-semibold text-lg">${day.date}</p>
                            <p class="text-gray-700"><strong>Wind:</strong> ${day.hasWind ? `${day.minWind.toFixed(1)} - ${day.maxWind.toFixed(1)} kts` : 'N/A'}</p>
                            <p class="text-gray-700"><strong>Wave:</strong> ${day.hasWave ? `${day.minWave.toFixed(1)} - ${day.maxWave.toFixed(1)} m` : 'N/A'}</p>
                            <p class="text-gray-900 font-bold">Conditions: <span class="text-gray-700">${conditions}</span></p>
                        </div>
                    `;
                    waypointHtml += cardHtml;
                });
                waypointHtml += `</div>`;
                htmlContent += waypointHtml;
            });

            if (failedWaypoints.length > 0) {
                htmlContent = `<div class="message-box error mb-4">
                    âš ï¸ Data unavailable for: ${failedWaypoints.map(w => w.replace(/_/g, ' ')).join(', ')}
                    </div>` + htmlContent;
            }

            contentDiv.innerHTML = htmlContent;
        }

        function renderTripAnalysis() {
            const contentDiv = elements.tripAnalysisContent;
            contentDiv.innerHTML = '';

            if (!state.tripAnalysis) {
                contentDiv.innerHTML = '<div class="message-box warning">Please run an analysis to see the report.</div>';
                return;
            }

            const analysis = state.tripAnalysis;
            let recClass = '';
            if (analysis.recommendation.includes("ðŸŸ¢")) recClass = 'bg-emerald-100 text-emerald-700';
            else if (analysis.recommendation.includes("ðŸŸ¡")) recClass = 'bg-yellow-100 text-yellow-700';
            else if (analysis.recommendation.includes("ðŸ”´")) recClass = 'bg-red-100 text-red-700';

            const analysisHtml = `
                <div class="space-y-4">
                    <div class="p-4 rounded-xl font-bold text-center text-lg ${recClass}">
                        ${analysis.recommendation}
                    </div>
                    <div class="p-4 bg-gray-100 rounded-xl text-sm text-gray-700 shadow-inner">
                        <p><strong>Status:</strong> ${analysis.status}</p>
                        <p><strong>Total Trip Duration:</strong> ${analysis.totalHours} hours</p>
                        <p><strong>Start Date:</strong> Day ${analysis.startDay} (${formatDate(new Date().setDate(new Date().getDate() + analysis.startDay - 1))})</p>
                    </div>
                    ${analysis.warnings.length > 0 ? `
                    <div class="p-4 bg-red-100 text-red-700 rounded-xl border border-red-200">
                        <h3 class="font-bold">Warnings:</h3>
                        <ul class="list-disc list-inside mt-2">
                            ${analysis.warnings.map(w => `<li>${w}</li>`).join('')}
                        </ul>
                    </div>` : ''}
                    <h3 class="text-lg font-bold mt-6 mb-2">Segment Breakdown</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white rounded-xl shadow overflow-hidden">
                            <thead class="bg-gray-200 text-sm">
                                <tr>
                                    <th class="py-2 px-4 text-left">Leg</th>
                                    <th class="py-2 px-4 text-left">From</th>
                                    <th class="py-2 px-4 text-left">Duration</th>
                                    <th class="py-2 px-4 text-left">Max Wind/Wave</th>
                                    <th class="py-2 px-4 text-left">Safety</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${analysis.segments.map(s => {
                                    let safetyColor = '';
                                    switch(s.safety) {
                                        case 'DANGEROUS': safetyColor = 'bg-red-200'; break;
                                        case 'MARGINAL': safetyColor = 'bg-orange-200'; break;
                                        case 'ACCEPTABLE': safetyColor = 'bg-yellow-200'; break;
                                        default: safetyColor = 'bg-emerald-200';
                                    }
                                    return `
                                    <tr class="border-t border-gray-100 text-sm">
                                        <td class="py-2 px-4 whitespace-nowrap">${s.name}</td>
                                        <td class="py-2 px-4 whitespace-nowrap">${s.from}</td>
                                        <td class="py-2 px-4">${s.duration}h</td>
                                        <td class="py-2 px-4">${s.maxWind}kt / ${s.maxWave}m</td>
                                        <td class="py-2 px-4"><span class="inline-block text-center py-1 px-2 rounded-full text-xs font-semibold ${safetyColor}">${s.safety}</span></td>
                                    </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            contentDiv.innerHTML = analysisHtml;
        }

        function renderFishingForecast() {
            const contentDiv = elements.fishingForecastContent;
            contentDiv.innerHTML = '';
            if (!state.tripAnalysis || !state.allWeatherData.Wanganella_Bank) {
                contentDiv.innerHTML = '<div class="message-box warning">Please run an analysis to see the fishing forecast.</div>';
                return;
            }

            const banksData = {
              'Wanganella_Bank': state.allWeatherData.Wanganella_Bank,
            };

            const fishingDays = [];
            const fishingSegments = CONFIG.ROUTE_SEGMENTS.filter(seg => seg.name.includes("Fishing Day"));

            let totalOutboundHours = 0;
            for (const segment of CONFIG.ROUTE_SEGMENTS) {
                if (segment.name.includes("Fishing Day")) {
                    break;
                }
                totalOutboundHours += segment.duration;
            }

            fishingSegments.forEach((segment, index) => {
                const bankData = banksData.Wanganella_Bank;
                if (!bankData) return;

                const fishingStartIndex = (state.startDateOffset * (24/CONFIG.INTERVAL_HOURS)) + Math.ceil(totalOutboundHours / CONFIG.INTERVAL_HOURS) + (index * (24/CONFIG.INTERVAL_HOURS));

                const fishingDayNumber = index + 1;
                let maxWind = 0, maxWave = 0, goodHours = 0;
                let fishingDate = "N/A";
                let hasWind = false;
                let hasWave = false;

                if (fishingStartIndex >= 0 && fishingStartIndex < bankData.length) {
                    fishingDate = formatDate(bankData[fishingStartIndex].time);
                    for (let i = fishingStartIndex; i < Math.min(fishingStartIndex + (24/CONFIG.INTERVAL_HOURS), bankData.length); i++) {
                        const data = bankData[i];
                        if (data) {
                            if (data.wind !== null) {
                                maxWind = Math.max(maxWind, data.wind);
                                hasWind = true;
                            }
                            if (data.wave !== null) {
                                maxWave = Math.max(maxWave, data.wave);
                                hasWave = true;
                            }
                            // Good hours logic still needs both data points
                            if (data.wind !== null && data.wave !== null && data.wind < 15 && data.wave < 1.5) {
                                goodHours += CONFIG.INTERVAL_HOURS;
                            }
                        }
                    }
                }

                const quality = goodHours >= 12 ? "Excellent" :
                                goodHours >= 8 ? "Good" :
                                goodHours >= 4 ? "Fair" : "Poor";

                fishingDays.push({
                    day: fishingDayNumber,
                    bank: 'Wanganella Bank',
                    date: fishingDate,
                    maxWind: hasWind ? maxWind.toFixed(1) : 'N/A',
                    maxWave: hasWave ? maxWave.toFixed(1) : 'N/A',
                    goodHours,
                    quality
                });
            });

            const tableHtml = `
                <div class="overflow-x-auto">
                    <table class="min-w-full bg-white rounded-xl shadow overflow-hidden">
                        <thead class="bg-gray-200 text-sm">
                            <tr>
                                <th class="py-2 px-4 text-left">Bank</th>
                                <th class="py-2 px-4 text-left">Trip Day</th>
                                <th class="py-2 px-4 text-left">Date</th>
                                <th class="py-2 px-4 text-left">Max Wind (kts)</th>
                                <th class="py-2 px-4 text-left">Max Wave (m)</th>
                                <th class="py-2 px-4 text-left">Good Hours</th>
                                <th class="py-2 px-4 text-left">Quality</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${fishingDays.map(day => {
                                let qualityColor = '';
                                switch(day.quality) {
                                    case 'Excellent': qualityColor = 'bg-emerald-200'; break;
                                    case 'Good': qualityColor = 'bg-yellow-200'; break;
                                    case 'Fair': qualityColor = 'bg-orange-200'; break;
                                    case 'Poor': qualityColor = 'bg-red-200'; break;
                                }
                                return `
                                <tr class="border-t border-gray-100 text-sm">
                                    <td class="py-2 px-4">${day.bank}</td>
                                    <td class="py-2 px-4">${day.day}</td>
                                    <td class="py-2 px-4">${day.date}</td>
                                    <td class="py-2 px-4">${day.maxWind}</td>
                                    <td class="py-2 px-4">${day.maxWave}</td>
                                    <td class="py-2 px-4">${day.goodHours}</td>
                                    <td class="py-2 px-4"><span class="block text-center py-1 px-2 rounded-full text-xs font-semibold ${qualityColor}">${day.quality}</span></td>
                                </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            contentDiv.innerHTML = tableHtml;
        }


        // --- Event Listeners and Main App Flow ---
        elements.runAnalysisBtn.addEventListener('click', async () => {
            hideMessage();
            elements.runAnalysisBtn.disabled = true;
            elements.runAnalysisBtn.textContent = 'Fetching Data...';
            try {
                showMessage('ðŸš€ Fetching live weather data and running analysis...', 'info');
                await saveSettings();
                state.allWeatherData = await fetchAllWaypointWeather();
                showMessage('âœ… Data fetch complete. Running trip analysis...', 'info');
                state.tripAnalysis = analyzeTrip(state.allWeatherData, state.startDateOffset);
                showMessage('âœ¨ Analysis complete!', 'success');
                renderUI();
            } catch (error) {
                console.error("Analysis failed:", error);
                showMessage('âš ï¸ Analysis failed. Please check the console for details.', 'error');
            } finally {
                elements.runAnalysisBtn.disabled = false;
                elements.runAnalysisBtn.textContent = 'Run Analysis';
            }
        });

        elements.clearCacheBtn.addEventListener('click', () => {
            hideMessage();
            state.allWeatherData = {};
            state.tripAnalysis = null;
            showMessage('Data cleared. You can run a new analysis.', 'info');
            renderUI();
        });

        elements.startDateSelect.addEventListener('change', (e) => {
            state.startDateOffset = parseInt(e.target.value);
        });

        elements.tabButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const tab = e.target.dataset.tab;
                elements.tabButtons.forEach(btn => btn.classList.remove('active'));
                elements.tabContents.forEach(content => content.classList.remove('active'));

                e.target.classList.add('active');
                document.getElementById(tab).classList.add('active');
            });
        });

        window.onload = () => {
          generateTripWaypoints();
          initializeFirebase();
        };
    </script>

</body>
</html>

